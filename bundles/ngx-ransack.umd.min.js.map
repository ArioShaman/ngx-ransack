{"version":3,"sources":["../../../projects/ngx-ransack/src/lib/models/ransack.enum.ts","../../../projects/ngx-ransack/src/lib/ngx-ransack.service.ts"],"names":["Ransack","NgxRansackService","prototype","toRansack","filters","options","_this","this","httpParams","HttpParams","Object","keys","forEach","key","Array","isArray","option","_setParam","matcher","filter","_kebabStr","name","hasOwnProperty","postfix","from","paramName","filterEl","set","str","split","map","el","toLowerCase","join","Injectable","args","providedIn"],"mappings":"yVAAA,IAAYA,GAAAA,EAAAA,EAAAA,UAAAA,EAAAA,QAAO,KACjBA,EAAA,GAAA,GAAA,KACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,GAAA,GAAA,KACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,GAAA,GAAA,KACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,GAAA,GAAA,KACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,QAAA,IAAA,UACAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,KAAA,IAAA,OACAA,EAAAA,EAAA,QAAA,IAAA,2BCJA,SAAAC,YA+FOA,EAAAC,UAAAC,UAAA,SAAUC,EAAcC,GAAxB,IAAAC,EAAAC,KACDC,EAAa,IAAIC,EAAAA,WA0BrB,OAxBaC,OAAOC,KAAKP,GACpBQ,SAAQ,SAACC,GACZ,GAAIC,MAAMC,QAAQV,EAAQQ,IAGxBR,EAAQQ,GAAKD,SAAQ,SAACI,GACpBR,EAAaF,EAAKW,UAAUD,EAAQZ,EAASS,EAAKL,WAE/C,GAAIH,EAAQQ,aAAgBH,OAAQ,CAGzC,IAAMM,EAASX,EAAQQ,GACvBL,EAAaF,EAAKW,UAAUD,EAAQZ,EAASS,EAAKL,OAC7C,CAGCQ,EAAS,CACbE,QAASb,EAAQQ,IAGnBL,EAAaF,EAAKW,UAAUD,EAAQZ,EAASS,EAAKL,OAI/CA,GAGDP,EAAAC,UAAAe,UAAA,SACND,EACAZ,EACAS,EACAL,GAEA,IAAIW,EAASf,EAAQS,GAEfK,EAAUX,KAAKa,UAAUpB,EAAAA,QAAQgB,EAAOE,UAExCG,EAAOL,EAAOM,eAAe,QACjCf,KAAKa,UAAUJ,EAAOK,MAAQd,KAAKa,UAAUP,GAEzCU,EAAUP,EAAOM,eAAe,WACpC,IAAIN,EAAOO,QAAY,GAErBP,EAAOM,eAAe,UACxBH,EAASA,EAAOH,EAAOQ,OAGzB,IAAIC,EAAY,KAAKJ,EAAOE,EAAO,IAAIL,EAAO,IAY9C,OAVIJ,MAAMC,QAAQI,IAChBM,GAAwB,KAExBN,EAAOP,SAAQ,SAACc,GACdlB,EAAaA,EAAWmB,IAAIF,EAAWC,OAGzClB,EAAaA,EAAWmB,IAAIF,EAAWN,GAGlCX,GAGDP,EAAAC,UAAAkB,UAAA,SAAUQ,GAChB,OAAOA,EAAIC,MAAM,aACdC,KAAI,SAACC,GAAO,OAAAA,EAAGC,iBACfC,KAAK,0HAvKXC,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY","sourcesContent":["export enum Ransack {\n  Eq,\n  NotEq,\n  Gt,\n  Gteq,\n  GtAny,\n  Lt,\n  Lteq,\n  LtAny,\n  In,\n  NotIn,\n  Present,\n  Blank,\n  Cont,\n  NotCont\n}\n","import { Injectable } from '@angular/core';\nimport { HttpParams } from '@angular/common/http';\n\nimport { Ransack } from './models/ransack.enum';\nimport { IRansackParam } from './models/ransack-param.interface';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NgxRansackService {\n  constructor() { }\n\n  /**\n    * Filters keys must be same with Options keys\n    *\n    * For example:\n    *\n    * filters: {\n    *   authorId: [1,2,3]\n    * }\n    *\n    * options: {\n    *   authorId: {\n    *     matcher: Ransack.In\n    *   }\n    * }\n  */\n\n  /** Filters is FormData */\n\n  /**\n    * Filters can take 3 types of Input params:\n    * Ransack enum operation\n    * Object of IRansackParam\n    * Array of objects IRansackParam\n    *\n    * For example\n    *\n    * {\n    *   authorId: {\n    *     matcher: Ransack.In,\n    *   },\n    *   price: [\n    *     {\n    *       matcher: Ransack.Gt,\n    *       from: 'min'\n    *    },\n    *    {\n    *       matcher: Ransack.Lt,\n    *       from: 'max'\n    *    }\n    *  ],\n    *  title: Ransack.NotEq,\n    *}\n  */\n\n  /**\n    * Options params:\n    *\n    ****\n    * matcher - choose ransack operation;\n\n    ****\n    * postfix - add postfix name to param, for example:\n    *\n    * option = {\n    *   author: {\n    *     postfix: 'id'\n    *   }\n    * }\n    *\n    * return: q[author_id_{matcher}]\n    *\n    ****\n    * name - change naming ransack params from object key to custom name, \n    * for example:\n    *\n    * options = {\n    *   authorId: {\n    *     name: 'authorIds'\n    *   }\n    * };\n    *\n    * return: q[author_ids_{matcher}]\n    *\n    ****\n    * from - choose value of param from input Object by key, for example:\n    *\n    * filters = {\n    *   price: {\n    *     min: 1,\n    *     max: 10\n    *   }\n    * };\n    *\n    * options = {\n    *   price: {\n    *     mathcer: Ransack.Gt,\n    *     from: 'min'\n    *   }\n    * }\n    *\n    * return: 'q[price_gt] = 1'\n  */\n\n  public toRansack(filters: any, options?: any): HttpParams {\n    let httpParams = new HttpParams();\n\n    const keys = Object.keys(filters);\n    keys.forEach((key) => {\n      if (Array.isArray(options[key])) {\n        /** If Options is Array of options */\n\n        options[key].forEach((option) => {\n          httpParams = this._setParam(option, filters, key, httpParams);\n        });\n      } else if (options[key] instanceof Object) {\n        /** If Options is Option object */\n\n        const option = options[key];\n        httpParams = this._setParam(option, filters, key, httpParams);\n      } else {\n        /** If Options is Ransack operation */\n\n        const option = {\n          matcher: options[key]\n        };\n\n        httpParams = this._setParam(option, filters, key, httpParams);\n      }\n    });\n\n    return httpParams;\n  }\n\n  private _setParam(\n    option: IRansackParam,\n    filters: any,\n    key: string,\n    httpParams: HttpParams\n  ): HttpParams {\n    let filter = filters[key];\n\n    const matcher = this._kebabStr(Ransack[option.matcher]);\n\n    const name = option.hasOwnProperty('name') ?\n      this._kebabStr(option.name) : this._kebabStr(key);\n\n    const postfix = option.hasOwnProperty('postfix') ?\n      `_${option.postfix}` : '';\n\n    if (option.hasOwnProperty('from')) {\n      filter = filter[option.from];\n    }\n\n    let paramName = `q[${name}${postfix}_${matcher}]`;\n\n    if (Array.isArray(filter)) {\n      paramName = paramName + '[]';\n\n      filter.forEach((filterEl) => {\n        httpParams = httpParams.set(paramName, filterEl);\n      });\n    } else {\n      httpParams = httpParams.set(paramName, filter);\n    }\n\n    return httpParams;\n  }\n\n  private _kebabStr(str: string): string {\n    return str.split(/(?=[A-Z])/)\n      .map((el) => el.toLowerCase())\n      .join('_');\n  }\n\n}\n"]}